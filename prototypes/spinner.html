<html>
<head>

<style type="text/css">
#container {
    border: 1px solid black;
    width: 500px;
    height: 400px;
}
</style>

</head>
<body>
<div id="container"></div>
<script src="../toolkit/scripts/Three.js"></script>
<script src="../toolkit/scripts/Stats.js"></script>
<script src="../toolkit/scripts/jquery.js"></script>

<script type="text/javascript">
var container, stats;

var camera, scene, renderer;

var tri;

var targetRotation = 0;
var targetRotationOnMouseDown = 0;

var mouseX = 0;
var mouseXOnMouseDown = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

init();
animate();

var parent;

function init() {



container = document.createElement( 'div' );
document.getElementById("container").appendChild( container );

var info = document.createElement( 'div' );
info.style.position = 'absolute';
info.style.top = '10px';
info.style.width = '100%';
info.style.textAlign = 'center';
info.innerHTML = 'Drag to spin the cube';
container.appendChild( info );

scene = new THREE.Scene();

//    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
camera = new THREE.PerspectiveCamera( 70, 500/400, 1, 1000 );
camera.position.y = 150;
camera.position.z = 500;
scene.add( camera );


parent = new THREE.Object3D();
parent.position.y = 50;
scene.add( parent );



var extrudeSettings = {	amount: 20,  bevelEnabled: true, bevelSegments: 2, steps: 2 }; // bevelSegments: 2, steps: 2 , bevelSegments: 5, bevelSize: 8, bevelThickness:5,

var sqLength = 80;
var squareShape = new THREE.Shape();
squareShape.moveTo( 0,0 );
squareShape.lineTo( 0, sqLength );
squareShape.lineTo( sqLength+20, sqLength );
squareShape.lineTo( sqLength, 0 );
squareShape.lineTo( 0, 0 );
var squarePoints = squareShape.createPointsGeometry();
var squareSpacedPoints = squareShape.createSpacedPointsGeometry();
var square3d = squareShape.extrude( extrudeSettings );
//addGeometry( square3d, squarePoints, squareSpacedPoints,				0x0055ff,  150,  100, 0,     0, 0, 0, 1 );
//				function addGeometry( geometry, points, spacedPoints, color, x, y, z, rx, ry, rz, s ) {
var geometry = square3d;
var points = squarePoints;
var spacedPoints = squareSpacedPoints;
var color = 0x0055ff;
var x = 0; var y = 0; var z = 0; var rx = 0; var ry = 0; var rz = 0; var s = 1;

//var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [ new THREE.MeshLambertMaterial( { color: 0xff0000,
//	      shading: THREE.SmoothShading,
// } )
//, new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } )
// ] );

//var material = new THREE.MeshBasicMaterial( { color: 0x00ff00, shading: THREE.SmoothShading } );
var material = new THREE.MeshLambertMaterial( { color: 0xff0000, shading: THREE.FlatShading, overdraw: true });
//var material = new THREE.MeshLambertMaterial( { color: 0xff0000, shading: THREE.FlatShading, overdraw: true } );

var mesh = new THREE.Mesh(geometry, material);

mesh.position.set( x, y, z - 75 );
mesh.rotation.set( rx, ry, rz );
mesh.scale.set( s, s, s );
parent.add( mesh );

/*
var line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: color, linewidth: 2 } ) );
line.position.set( x, y, z + 25 );
line.rotation.set( rx, ry, rz );
line.scale.set( s, s, s );
parent.add( line );


// transparent line from real points

var line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: color, opacity: 0.5 } ) );
line.position.set( x, y, z + 75 );
line.rotation.set( rx, ry, rz );
line.scale.set( s, s, s );
parent.add( line );

// vertices from real points

var pgeo = THREE.GeometryUtils.clone( points );
var particles = new THREE.ParticleSystem( pgeo, new THREE.ParticleBasicMaterial( { color: color, size: 2, opacity: 0.75 } ) );
particles.position.set( x, y, z + 75 );
particles.rotation.set( rx, ry, rz );
particles.scale.set( s, s, s );
parent.add( particles );

// transparent line from equidistance sampled points

var line = new THREE.Line( spacedPoints, new THREE.LineBasicMaterial( { color: color, opacity: 0.2 } ) );
line.position.set( x, y, z + 100 );
line.rotation.set( rx, ry, rz );
line.scale.set( s, s, s );
parent.add( line );

// equidistance sampled points

var pgeo = THREE.GeometryUtils.clone( spacedPoints );
var particles2 = new THREE.ParticleSystem( pgeo, new THREE.ParticleBasicMaterial( { color: color, size: 2, opacity: 0.5 } ) );
particles2.position.set( x, y, z + 100 );
particles2.rotation.set( rx, ry, rz );
particles2.scale.set( s, s, s );
parent.add( particles2 );
//				}
*/


/*
// create a point light
var pointLight =
  new THREE.PointLight(0xFFFFFF);

// set its position
pointLight.position.x = 100;
pointLight.position.y = 200;
pointLight.position.z = 100;

// add to the scene
scene.add(pointLight);
*/


var light = new THREE.DirectionalLight( 0xffffff );
light.position.set( 0, 0, 1 );
scene.add( light );



/*
var pointLight =
  new THREE.PointLight(0xFFFFFF);

// set its position
pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;

// add to the scene
scene.add(pointLight);
*/



//create a renderer
renderer = new THREE.CanvasRenderer();
//renderer.setSize( 500,400);

//renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setSize( 500, 400);//window.innerWidth, window.innerHeight );


//add renderer to the screen
container.appendChild( renderer.domElement );

//add stats for debugging
/*
stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
container.appendChild( stats.domElement );
*/

$("#container").mousedown(function(e){
    targetRotation += 0.2;
})
$("#container").mousemove(function(e){
    targetRotation += 0.1;
})

	container.addEventListener('touchmove', function(event) {
	    event.preventDefault();
	    var touch = event.touches[0];
	   	targetRotation -= 0.1;
	    //func({x:touch.pageX});
	    //dx = -touch.pageX/7.0;
	});

}

function animate() {
    requestAnimationFrame( animate );
    render();
//    stats.update();
}

function render() {
//	parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;
//	parent.rotation.y += 0.05;
	parent.rotation.y = targetRotation;
//    plane.rotation.z = cube.rotation.y += 
//        ( targetRotation - cube.rotation.y ) * 0.05;
    renderer.render( scene, camera );
}

</script>
</body>
</html>
